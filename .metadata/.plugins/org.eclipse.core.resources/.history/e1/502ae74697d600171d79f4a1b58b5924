类：
	类是事物的抽象，类可以用来描述一个具体的事物，
	类中包含方法和属性。
	
方法用来描述事物的行为，
方法组成：权限修饰符，返回值类型，方法名，参数列表，
		方法体
main方法是程序的主入口，当java程序开始执行时，就会
	从这里开始。
构造方法：构造方法方法名和类名相同，并且没有返回值
	可以在构造方法中对属性进行初始化。
	当创建一个类时，就会调用它的构造方法。
	每个类都默认拥有一个无参的构造方法。
	当我们手动增加一个构造方法时就会覆盖这个默认的构造方法。
方法的重载和重写:
	方法的重载：发生在一个类中，方法名相同，参数列表不同（参数的类型，个数，顺序有一
			个不同，它的参数列表就不同）
			我们可以通过传入对应方法的参数列表的数据来选择调用哪个方法
	方法的重写：发生在父子类之间，方法名和参数列表都相同，方法的权限不能更严格
			当子类需要对从父类继承来的方法进行修改时，就可以将方法重写
形参和实参：在方法定义时参数列表中定义的参数叫做形参
			在调用方法时向方法中传入的参数叫做实参
	
对象：可以同过new关键字创建一个对象
	类名  对象名 = new 类名();其中对象名是一个引用，保存对象的地址。保存在栈中
	new关键字创建一个对象，开辟一个堆内存空间，对象保存在堆中
匿名对象：没有对象名的对象。new 类名();可以作为实参直接传入参数列表中
		当一个对象只需要使用一次时，可以直接使用匿名对象	
包：package包用来区分同名的类
	包的命名：公司网址的倒置。
	
权限修饰符：
	public(共有的)：可以在任何地方被使用
	protected(受保护的)：只能被同包或子类中使用
	什么都不写表示默认的：只能在同包中使用
	private(私有的)：只能在本类中使用

String:String表示字符串，String不是基本数据类型
		字符串是不可改变的，当一个字符串被创建后它就不能再发生改变
		equals是字符串的比较方法，能比较两个字符串是否相等。s1.equals(s2);
		
面向对象的三大特性：封装，继承，多态
封装：隐藏实现细节，仅对外提供访问的方法
	私有属性，私有方法都是封装性的体现
继承：子类继承父类的属性和方法
	子类可以通过extends关键字继承父类的属性和方法
多态：父类的引用指向它子类的对象，父接口的引用指向它实现类的对象

super和this：
	子类可以通过super调用父类的属性和方法 super.属性 ; super.方法名();
	this:当前类对象。当一个对象调用含this的方法时，this就指向这个对象。

成员变量和局部变量
	成员变量定义在类中方法外，在对象产生时产生，对象消失时销毁
	局部变量定义在方法中中，在方法调用时产生，方法结束后消失

static关键字：静态的
	static修饰的属性和方法储存在静态区中，依赖于类而不依赖于对象，可以被类直接调用
	类名.属性;类名.方法名();
	静态方法中不能使用费静态的属性
	
final关键字：最终的，不可变的
	final修饰的类不能被继承
	final修饰的方法不能被重写
	final修饰的属性不能被更改，被称为常量。

抽象方法：没有方法体的方法就是抽象方法，抽象方法一定要有abstract关键字修饰
		public abstract void play();
抽象类：用abstract修饰的类就是抽象类，不能通过new关键字创建抽象类的对象
	有抽象方法的类一定是抽象类，抽象类不一定有抽象方法
	抽象类中的抽象方法一定要被子类所实现，除非子类也是抽象类
	
接口：interface
	使用interface来定义一个接口。interface 类名{}。接口和类是同级别的
	接口中的方法都是抽象方法。public abstract 返回值类型 方法名();
	接口中的属性都是静态的常量。public static final 类型 属性名 = 属性值;
	接口和抽象类一样不能实例化对象
	implements用来实现一个接口
	class A implements P{} P是一个接口，A类实现了这个接口，A被称为P的实现类
	一个类可以实现多个接口

强制类型转换：
	父类/父接口 类型的引用可以接受其子类/实现类 的对象
	eg.  
	A是接口 B类实现了A
	A a = new B ();
	但此时的引用这能调用子类从父类继承的方法不能调用子类自己的方法。
	此时我们需要将对象传递给子类类型的引用，这时就要用到强制类型转换
	B b = (B)a;
	将A类型的引用a强制转换为B类型的引用并赋值给b
	
	此时就能通过b引用调用B类中自己的方法了
类型转换异常：
	在强制类型转换的时候，如果一个类被与它无关的类的引用指向，就会报错
	ClassCaseException 类型转换异常
	eg：
		A是接口 ， B类和C类实现了A
		虽然B和C都是A接口的实现类，但B和C并没有关系
		A a = new B();
		C c = (C)a;
		此时将一个B类对象强行传递给一个C类的引用，就发生了类型转换异常

	







